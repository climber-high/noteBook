### 数据结构

>计算机如何组织和存储数据的一种逻辑结构。

#### 常见的数据结构

>数组、链表、队列、栈、散列表、二叉树

## 双向循环链表

>链表和数组

```
数组的优点：利用下标快速找到对应的元素。
数组的缺点：添加或者删除元素时，需要调整整个数组。

链表的优点：可以很方便地添加或者删除元素，并且可以利用零散的内存空间。
链表的缺点: 不能够直接利用下标快速找到对应的元素(需要遍历)。另外，链表节点需要存放指向前驱和后继节点的地址，
也就是说，相对于数组，需要占用更多的内存空间。
```

## 二叉树

>任意一个节点，最多只有两个子节点的树结构。

## 搜索二叉树(排序二叉树)

>要添加的节点跟根节点比，如果相等就不添加，不允许有重复元素

```
左子树上的节点的值都小于根节点，右子树上的节点的值都大于根节点。
左右子树也是一个搜索二叉树。
```

#### 可以使用红黑树来解决二叉树的失衡现象

>红黑树是一个自平衡搜索二叉树。就是说，添加(或者删除)元素时，会自动调整(通过旋转或者改变颜色)来确保这是一个相对平衡的搜索二叉树。

## 散列表

>是一种利用关键码值(key)快速找到对应记录的数据结构，也就是说，它可以利用关键码值映射到表中的某条记录，其中，映射到表中的记录的函数称之为散列函数，存放记录的数组称之为散列表。

```
散列函数的作用：
	依据关键码值的hashcode进行计算，得到一个位置(即
	散列表的下标)。
散列冲突:
	散列函数在进行计算时，虽然hashcode不一样，但是可能
	计算得到的结果一样。
	发生散列冲突，会导致散列桶(链表结构)变长，查询时性能
	会下降。
	在向散列表添加元素时，如果超过了临界值，则散列表会扩容，
	注意，扩容会导致重新散列，频繁地重新散列，会影响性能，所以，
	在实际使用散列表，最好事先估算好元素的个数，指定散列表的
	大小。

负载因子(loadfactor):
	当散列表中的数据超过临界值时，散列表需要重新扩容。
	临界值 = 散列表的长度 * 负载因子。
	比如，当前散列表的长度是16,负载因子是0.75,则临界值是
	16 * 0.75 = 12。
```

#### 向散列表添加元素的过程:
```
step1.依据关键码值(key)的hashcode进行计算(调用散列函数),得到
散列表中散列桶(链表结构)的存储位置(即数组的下标)。

step2.依据下标找到散列桶，接下来通过equals方法来比较散列桶当中
存放的元素的关键码值，如果相等，则替换，否则添加到散列桶里面(
即添加到链表里面)。
```
	
**注意:如果添加的元素的个数超过了临界值，则散列表会重新扩容。扩容会导致重新散列，频繁地重新散列，会影响性能，所以，在实际使用散列表，最好事先估算好元素的个数，指定散列表的大小。**


#### 向散列表查询某个元素的过程

```
step1.依据关键码值(key)的hashcode进行计算(调用散列函数),得到
散列表中散列桶(链表结构)的存储位置(即数组的下标)。

step2.依据下标找到散列桶,通过equals方法来比较散列桶当中
存放的元素的关键码值，如果相等，则返回该记录。
```

