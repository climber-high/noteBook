### ES5,6,7

## 严格模式

>使javaScript在更严格的语法条件下运行，消除语法的不合理，不严谨，减少怪异行为，消除不完全之处，为
新版本javaScript做好铺垫

>使用

在全局或函数的第一条语句定义为'usr strict'

>语法和行为改变

1. 必须用var声明变量
2. 禁止自定义的函数中的this这项window(创建构造函数并直接调用，this会指向window，会报错)
3. 创建eval作用域(如果全局变量和eval内声明变量为同个变量名，不会相互影响)
4. 对象不能有重名属性

## JSON对象

```
JSON.stringify(obj)
JSON.parse(obj)
```

## Object拓展

>Object.create(prototype, [descriptors])

```
作用：以指定对象为原型创建新的对象

为新的对象指定新的属性，并对属性进行描述
value: 指定值
writable: 标识当前属性值是否可修改的，默认为false
configurable: 标识当前属性是否可以被删除，默认为false
enumerable: 标识当前属性是否能用for in 枚举，默认为false

var obj = {username: 'zs', age: 18};
var obj1 = {};
obj1 = Object.create(obj,{
	sex: {
		value:'男',
		writable: true,
		configurable: true
	}
})
obj1.sex = '女'
delete obj1.sex
```

>Object.defineProperties(object, prop, descriptor)

```
为指定对象定义扩展一个属性

var obj = new Object();

Object.defineProperty(obj, 'name', {
    configurable: false,
    writable: true,
    enumerable: true,
    value: '张三'
})
```

>Object.defineProperties(object, props)

```
作用: 为指定对象定义扩展多个属性

get : 用来获取当前属性值得回调函数
set : 修改当前属性值得触发得回调函数，并且实参即为修改后得值
存取器属性，setter,getter一个用来存值，一个用来取值

var obj2 = {firstName: 'zs' , lastName : 'ls'};
Object.defineProperties(obj2,{
	fullName: {
		get:function(){ //获取拓展属性的值，获取扩展属性值的get方法自动调用
			return this.firstName+" "+lastName;
		},
		set: function(data){ //监听拓展属性，当扩展属性发生变化的时候会自动调用
			自动调用后会将变化的值作为实参注入到set函数
			data为修改对象属性值的'ww zs'
			console.log(data);
		}
	}
})
obj2.fullName='ww zs'; //修改了才会调用set方法
```

>对象本身的两个方法

1. get propertyName(){} 用来得到当前属性值的回调函数
2. set propertyName(){} 用来监听当前属性值变化的回调函数

```
var obj = {
	firstName: 'zs', 
	lastName : 'ls',
	get fullName(){
		return this.firstName + ' ' + lastName;
	}
	set fullName(data){ //fullName值改变时调用
		console.log(data);
	}
}
console.log(obj);
obj.fullName='ww zs';
```