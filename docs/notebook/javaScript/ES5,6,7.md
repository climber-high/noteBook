### ES5,6,7

## ES5

## 严格模式

>使javaScript在更严格的语法条件下运行，消除语法的不合理，不严谨，减少怪异行为，消除不完全之处，为
新版本javaScript做好铺垫

>使用

在全局或函数的第一条语句定义为'usr strict'

>语法和行为改变

1. 必须用var声明变量
2. 禁止自定义的函数中的this指向window(创建构造函数并直接调用，this会指向window，会报错)
3. 创建eval作用域(如果全局变量和eval内声明变量为同个变量名，不会相互影响)
4. 对象不能有重名属性

## JSON对象

```
JSON.stringify(obj)
JSON.parse(obj)
```

## Object扩展

>Object.create(prototype, [descriptors])

```
作用：以指定对象为原型创建新的对象

为新的对象指定新的属性，并对属性进行描述
value: 指定值
writable: 标识当前属性值是否可修改的，默认为false
configurable: 标识当前属性是否可以被删除，默认为false
enumerable: 标识当前属性是否能用for in 枚举，默认为false

var obj = {username: 'zs', age: 18};
var obj1 = {};
obj1 = Object.create(obj,{
	sex: {
		value:'男',
		writable: true,
		configurable: true
	}
})
obj1.sex = '女'
delete obj1.sex
```

>Object.defineProperty(object, prop, descriptor)

```
为指定对象定义扩展一个属性

var obj = new Object();

Object.defineProperty(obj, 'name', {
    configurable: false,
    writable: true,
    enumerable: true,
    value: '张三'
})
```

>Object.defineProperties(object, props)

```
作用: 为指定对象定义扩展多个属性

get : 用来获取当前属性值得回调函数
set : 修改当前属性值得触发得回调函数，并且实参即为修改后得值
存取器属性，setter,getter一个用来存值，一个用来取值

var obj2 = {firstName: 'zs' , lastName : 'ls'};
Object.defineProperties(obj2,{
	fullName: {
		get:function(){ //获取拓展属性的值，获取扩展属性值的get方法自动调用
			return this.firstName+" "+lastName;
		},
		set: function(data){ //监听拓展属性，当扩展属性发生变化的时候会自动调用
			自动调用后会将变化的值作为实参注入到set函数
			data为修改对象属性值的'ww zs'
			console.log(data);
		}
	}
})
obj2.fullName='ww zs'; //修改了才会调用set方法
```

>对象本身的两个方法

1. get propertyName(){} 用来得到当前属性值的回调函数
2. set propertyName(){} 用来监听当前属性值变化的回调函数

```
var obj = {
	firstName: 'zs', 
	lastName : 'ls',
	get fullName(){
		return this.firstName + ' ' + lastName;
	}
	set fullName(data){ //fullName值改变时调用
		console.log(data);
	}
}
console.log(obj);
obj.fullName='ww zs';
```

## 数组的扩展

>Array.prototype.map(function(item,index){})

```
遍历数组返回一个新的数组，返回加工之后的值
```

>Array.prototype.filter(function(item,index){})

```
遍历过滤出一个新的子数组，返回条件为true的值
```

## 函数Function扩展

>Function.prototype.bind(obj);

**作用:将函数内的this绑定为obj，并将函数返回**

##### 区别bind()与call()和apply

```
1. 都能指定函数中的this
2. call()/apply()是立即调用函数
3. bind()是将函数返回  (通常用于指定回调函数的this)

4. bing(obj,33,...)() 传参一个接着一个,调用
   call(obj,33,...) 传参一个接着一个
   apply(obj,[44,55]) 只有两个参数，data必须用数组装起来
```

例:
```
var obj = {username : 'zs'};
function foo(data){
	console.log(this,data);
};

foo();  //window
foo.bind(obj,33)();  //obj 是将函数返回，还要()调用

foo.call(obj,33);	  //obj 立即调用函数，不用()调用
foo.apply(obj,[44]);	  //obj 立即调用函数，不用()调用
```

>bind()通常用于指定回调函数的this

```
setTimeout(function(){
	console.log(this)
}.bind(obj),1000)
```

# ES6

## let和const

> let(用于声明一个变量)

特点:
```
1.在块级作用域内有效
2.不能重复声明
3.不会预处理(预解析)，不存在变量提升
```

应用:
```
1.循环遍历加监听
```

> const(定义一个常量)

特点:
```
1.不能修改
2.其他特点同let
```

应用:
```
保存不用改变的数据
```

## 变量的解构赋值

>从对象或数组中提取数据，并赋值给变量(多个)

1. 对象的赋值

```javascript
let {username,age} = {username:'tom',age:12};

let obj = {username:'tom',age:12};
function foo({username,age}){
	console.log(username,age)
}
foo(obj);
```

2. 数组的结构赋值

```
let [a,b] = [1,'c']

let a = 1; //数值交换
let b = 2;
[a,b] = [b,a];
```

## 模板字符串

>简化字符串的拼接

```
`字符串${}`
```

## 对象简写

>对象中同名的属性可以省略不写,还可以省略函数的function

```
let username = 'tom';
let obj = {
	username,
	getName(){
		return this.username;
	}
};
```

## 箭头函数

>定义匿名函数,多用来定义回调函数

基本用法:
```
* 没有参数: () => console.log('xxx');
* 一个参数: i => i+2
* 大于一个参数:(i,j) => i+j
* 函数体如果有一条语句,函数体不用大括号：默认返回结果
	let fun = (x,y) => x+y
	console.log(fun(1,2))  //3
	
	let fun = (x,y) => {x+y}
	console.log(fun(1,2))  //undefined

* 函数体如果有多条语句，需要用{}包围，若有需要返回的内容，需要手动返回
	let fun = (x,y) => {return x+y}
	console.log(fun(1,2))  //3
```

特点:
```
1. 简洁
2. 箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，
而是在定义的时候处在的对象就是它的this(使用外层对象的this)
3. 扩展理解: 箭头函数的this看外层的*是否有函数*
      如果有，外层函数的this就是内部箭头函数的this
      如果没有，则this是window
```

例:
```
let arr = [3,2,1];  //排序
arr.sort((a,b)=>a-b);

let obj = {
	'username':'tom',
	getN(){
		console.log(this);  //obj
	},
	getName: () => console.log(this)  //window
}
obj.getN();
obj.getName();
```

## 三点运算符

1. rest(可变)参数

>用来取代arguments,但比arguments灵活，`只能是最后部分形参`

```
function fun(a,...values){
	// arguments 伪数组
	// arguments.callee() //指向函数本身
}
```

2. 扩展运算符

```
let arr = [1,6];
let arr1 = [2,3,4,5];
arr = [1,...arr1,6];
console.log(arr);  //[1,2,3,4,5,6]
console.log(...arr) //1 2 3 4 5 6
```

## 形参默认值

>当不传入参数的时候默认使用形参里的默认值

```
function Point(x=1,y=2){
	this.x = x;
	this.y = y;
}
let point = new Point();
console.log(point);
```

## Promise对象

>代表了未来某个将要发生的事情(通常是一个异步操作)

>通过执行异步任务的结果去修改promise的状态来调用他实例对象里面then的成功或失败的回调

1. 有了promise对象，可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调函数(回调地狱)
2. ES6的Promise是一个构造函数，用来生成promise实例

**使用promise基本步骤:**

```
1.创建promise对象
let promise = new Promise((resolve,reject) => {
	//初始化promise状态为pending
	//执行异步操作
	if(异步操作成功){
		resolve(value); //修改promise的成功状态fullfilled
	}else{
		reject(errMsg); //修改promise的失败状态为rejected
	}
})


2.调用promise的then()
promise.then(
	result => console.log(result),
	errorMsg => alert(errorMsg)
)
```

>基于Promise封装原生AJAX

```
function ajax(method, url) {
	return new Promise((resolve, reject)=> {
		var xhr = new XMLHttpRequest();
		xhr.open(method, url);
		xhr.setRequestHeader("Authorization","Bluejj")
		xhr.send()
		xhr.addEventListener("readystatechange", ()=> {
			if(xhr.status == 200 && xhr.readyState == 4) {
				resolve(xhr.response)
			} else {
//				reject(xhr.statusText)
			}
		})
	})
}
var domain=" https://www.easy-mock.com/mock/5aa77cc42b0894377fc76659"
ajax("GET",domain+'/users?id=10&&name=bluej').then((res,err)=>{
	console.log(JSON.parse(res))
	err?console.log(err):"";
	
	return ajax("GET",domain+'/users?id=10&&name=bluej'); 再次调用
}).then(()=>{成功} , ()=>{失败})
```

## Symbol属性

>ES6中的添加了一种原始数据类型symbol

`特点:`

```
1. Symbol属性对应的值是*唯一的*，解决命名冲突问题，可以用来定义常量
2. Symbol值*不能与其他数据进行计算*,包括同字符串拼串
3. for in, for of 遍历时*不会遍历symbol属性*
```

`使用`

```
1. 调用Symbol函数得到symbol值
	let symbol = Symbol();
	let obj = {};
	obj[symbol] = 'hello';  //不能用点属性名来添加symbol属性
	
2. 传参标识
	let symbol = Symbol('one');
	let symbol2 = Symbol('two');
	console.log(symbol);  // Symbol(one)
	console.log(symbol2);  // Symbol(two)
	
3. 内置Symbol值
	* 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法
	- Symbol.iterator
	* 对象的Symbol.iterator属性，指向该对象的默认遍历器方法
	
	等同于在指定的数据结构上部署iterator接口
	当使用for of去遍历某一个数据结构的时候，首先去找Symbol.iterator,找到就能遍历
	let targetData = {
		[Symbol.iterator]: function(){
			let nextIndex = 0; //记录指针位置
			return{  //返回遍历器对象
				next :function(){
					return nextIndex<arr.length?
					{value:arr[nextIndex++],done:false}:
					{value:undefined,done:true};
				}
				
			}
		}
	};
```

## iterator

>是一种接口机制，为各种不同的数据结构提供统一的访问机制

`作用`:

1. 为各种数据结构，提供一个统一的、简便的访问接口
2. 使得数据结构的成员能够按某种次序排序
3. ES6创造了一种新的遍历命令for...of 循环，Iterator接口主要供for...of消费

`工作原理`:

- 创建一个指针对象(遍历器对象)，指向数据结构的起始位置
- 第一次调用next方法，指针会自动指向数据结构的第一个成员
- 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员
- 每调用next方法返回的是一个包含value和done的对象,{value:当前成员的值，done:布尔值}
	* value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束
	* 当遍历结束的时候返回的value值是undefined，done值为true

**原生具备iterator接口的数据(可用for of遍历)**

`理解`:

```
1. 当数据结构上部署了Symbol.iterator接口,并创建遍历器对象，该数据就是可以用for of遍历
2. 当使用for of去遍历目标数据的时候，该数据会自动去找Symbol.iterator属性

let obj = {username:'zs',age:18};
obj[Symbol.iterator] = function* myTest(){
	yield 1
	yield 2
	yield 3
}
for(let i of obj){  //对象本来不可以用for of
	console.log(i) //1 2 3
}
```

例:
```
function myInterator(arr){
	let nextIndex = 0;
	return{
		next :function(){
			return nextIndex<arr.length?
			{value:arr[nextIndex++],done:false}:
			{value:undefined,done:true};
		}
		
	}
}

let arr = [1,5,6,7];
let iteratorObj = myInterator(arr);
for(let i=0;i<=arr.length;i++){
	console.log(iteratorObj.next());
}
```

**使用三点运算符，结构赋值，默认去调用iterator接口**

## Generator函数

`定义`:

```
1.ES6提供的解决异步编程的方案之一
2.Generator函数是一个状态机，内部封装了不同状态的数据
3.可以用来生成遍历器对象
4.可暂停函数/Generator函数(惰性求值),yield可暂停，next方法可启动。每次返回的是yield后的表达式结果
```

`特点`:

```
1.function 与函数名之间有一个星号
2.内部用yield表达式来定义不同的状态

例如:
	function* generatorExample(){
		let result = yield 'hello'; //状态值为hello
		console.log(result);  //默认undefined。传参后会展示参数aaa
		yield 'generator'; //状态值为generator
		return '指针指到再没有value时返回的东西' //不写return本来返回undefined
	}
	generatorExample(); //返回的是指针对象
	generatorExample().next(); //会返回指针对象
	generatorExample().next('aaa'); //next方法可以传参数作为yield的返回值

3.generator函数返回的是指针对象，而不会执行函数内部逻辑
4.调用next方法函数内部逻辑开始执行，遇到yield表达式停止，
返回{value:yield后的表达式结果/undefined,done:false/true}
5.再次调用next方法会从上一次停止时的yield处开始，直到最后
6.yield语句返回结果通常为undefined,当调用next方法时传参内容会作为启动时yield语句的返回值。
```

例:
```

```