### 多线程
>多线程主要解决的问题是改变代码的执行方式，将原有的代码一句一句先后运行的"串行"操作，改为可以同时执行的"并行"操作。

**创建线程有两种方式**

1.继承Thread重写run方法定义线程任务

	缺点:
	一、由于java是单继承的，这导致如果继承例Thread就无法再继承其他类去复用方法，实际开发很不方便。
	二、定义线程的同时重写run方法定义任务，这导致线程与任务有一个必然的耦合关系，不利于线程的重用。

2.实现Runnable接口单独定义线程任务。


1.例:
```
threa1.d1 t1 = new thread1();
//启动线程要调用start方法而不是直接调用run方法，start方法调用后线程纳入线程调度器管理，
当分配到时间片后会自动调用run方法开始执行任务。
t1.start();

class thread1 extends Thread{
	public void run() {
		for(int i=0;i<1000;i++) {
			System.out.println("abc");
		}
	}
}
```

2.例:
```
MyRunnable1 r1 = new MyRunnable1();
Thread t1 = new Thread(r1);
t1.start();

class MyRunnable1 implements Runnable{
	public void run() {
		for(int i=0;i<1000;i++) {
			System.out.println("abc");
		}
	}
}
```

>使用匿名内部类完成线程的两种创建

1.直接继承Thread重写run方法


    Thread ti = new Thread(){
        public void run(){
            for(int i=0;i<1000;i++){
                System.out.println("你是谁啊");
            }
        }
    }
    ti.start();


2.实现Runnable接口

	Runnable r2 = new Runnable() {
        public void run() {
            for(int i=0;i<1000;i++) {
                System.out.println("我是查水表的!");
            }
        }
    };
    Thread t2 = new Thread(r2);
    t2.start();

## static Thread currentThread()

>线程提供了一个静态方法，该方法可以获取运行这个方法的线程。

**java中所有的代码都是靠线程运行的，mian方法也不例外，只不过运行main方法的线程不是有我们创建的**

```
Thread t2 = Thread.currentThread();
```

## static void sleep(long ms)  Sleep阻塞

>该方法可以让运行这个方法的线程阻塞指定毫秒，超时后线程会自动回到RUNNABLE状态等待再次并发运行。

例:
```
try {   //需要捕获异常
    Thread.sleep(5000);
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

**sleep方法要求必须处理中断异常。当一个线程调用sleep方法处于阻塞状态的过程中，它的中断方法interrupt()被调用时，那么会打断该线程的睡眠阻塞，此时sleep方法就会抛出中断异常。**

>interrupt() 中断阻塞

例:
```
Thread lin = new Thread() {
    public void run() {
        try {
            Thread.sleep(10000000);
        } catch (InterruptedException e) {
            System.out.println("被中断堵塞，输出");
        }
        System.out.println("也输出");
    }
};

lin.interrupt();//中断lin线程的睡眠阻塞
```


## 获取线程信息的相关方法

||Thread main = Thread.currentThread();|
|:--:|:--:|
|获取线程名字|String name = main.getName();|
|获取线程id|long id = main.getId();|
|获取优先级 |int priority = main.getPriority(); |
|线程是否活着|bollean isAlive = main.isAlive();|
|是否为守护线程|boolean isDeamon = main.isDaemon();|
|线程是否被中断|boolean isInterrupted = main.isInterrupted();|

## 线程优先级

>线程优先级共有10个等级，分别对应整数1-10。其中1最低，5默认，10最高。理论上线程优先级越高的线程获取CPU时间片的次数越多

**线程启动后便纳入到线程调度器中被统一管理，线程不能主动索取时间片，只能被动被分配。我们可以通过调整线程的优先级最大程度改善线程获取CPU时间片的几率。**

>设置线程优先级(线程.setPriority)





