### 集合框架

>java.util.Collection接口，该接口时集合的顶级接口，所有集合实现类都实现了该接口。它里面定义了所有集合都必须具备的功能。

**注意:集合只能存放引用类型元素,并且保存的也是元素的引用(地址)**

**Collection下面有两个常见的子接口:**

1.java.util.List:可重复集合，且有序。
2.java.util.Set:不可重复集合，大部分实现类无序。

```
集合也可以保存一组元素，并且提供了对元素的相关操作方法，使用起来比数组更便捷。并且有多种不同的数据结构，可结合实际开发需求选取。
```

>int size()

**返回当前集合中的元素个数**

例:
```
int size = c.size();
System.out.println(size);  //1
```

>boolean isEmpty()

**判断当前集合是否为空集，当集合中不含有元素时返回值为true**

例:
```
boolean isEmpty = c.isEmpty();
System.out.println(isEmpty);  //false;
```

>void clear()

**清空集合**

>boolean add(E e)  //E:泛型

**向集合中添加元素，成功添加后返回true**

例:
```
Collevtion c = new ArrayList();
boolean b = c.add("a");
System.out.println(b);  //true
```

>boolean addAll(Collection c)

**将给定集合中的所有元素添加到当前集合中**

例:
```
Collection c1 = new ArrayList();
c1.add("a");
c1.add("b");
c1.add("c");

Collection c2 = new ArrayList();
c2.add("1");
c2.add("2");
c2.add("3");

c1.addAll(c2);
System.out.println(c1);  //[a,b,c,1,2,3]
```

>boolean remove(Object o)

**remove方法在删除元素时也是将集合中与给定元素equals比较为true的删除。注意，对于List集合而言，若存在重复的元素，仅删除一个**

例:
```
c.remove(p);
```

>boolean removeAll(Collection c)

**删除当前集合中与给定集合的共有元素**

例:
```
Collection c3 = new ArrayList();
c3.add("a");
c3.add("b");
c3.add("d");

Collection c4 = new ArrayList();
c4.add("b");
c4.add("c");

c3.removeAll(c4);
System.out.println(c3);  //[a,d]  c3集合会改变
System.out.println(c4);  //[b,c]  c4不会改变
```

>boolean contains(Object o)

**判断集合是否包含给定元素(要重写equals方法，否则只会用==判断)**

例:
```
Collection c = new ArrayList();
c.add(new Point(1,2));

Point p = new Point(1,2);
boolean con = c.contains(p);  //true

//contains方法判断元素是否被包含的标准是根据给定元素与集合现有元素顺序equals比较，若有比较结果为true的就认为包含。因此集合元素equals方法直接影响比较结果
```

>boolean containsAll(Collection c)

**判断当前集合是否包含给定集合中的所有元素**

例:
```
Collection c1 = new ArrayList();
c1.add("a");
c1.add("b");
c1.add("c");

Collection c3 = new ArrayList();
c3.add("a");
c3.add("b");

boolean collAll = c1.containsAll(c3);
System.out.println(collAll);   //true
```

## 集合的遍历 iterator()

>Collection提供了一个用于遍历集合元素的方法:Iterator iterator(),该方法会获取一个用于遍历当前集合的迭代器.

**java.util.Iterator接口**

迭代器接口,不同的集合都实现了一个迭代器的实现类,但是我们无需记住它们,只当它们是迭代器Iterator看待即可,该接口定义了用于遍历集合的相关方法.

而遍历集合遵循的步骤为:问,取,删. 
其中删除元素不是遍历过程中的必要操作

例:
```
Collection c = new ArrayList();
c.add("one");
c.add("#");
c.add("two");

Iterator it = c.iterator();

//boolean hasNext() 判断是否集合中还有下一个元素可以遍历

while(it.hasNext()) {
	//E next()   获取集合下一个元素
    String line = (String)it.next();
    System.out.println(line);
    
    //迭代器也提供了remove方法，删除的是通过next方法的得到	   的元素
    if("#".equals(line)){
    	it.remove();
    }
}
```

**注意**:迭代器有一个要求，就是遍历的过程中不得通过集合的方法增删元素，否则遍历会出现异常

## 增强型for循环

>JDK5之后推出了一个特性:增强型for循环，也称为新循环,for each

**新循环不取代传统for循环的工作，它仅用来遍历集合或数组使用。并且新循环的语法是编译器认可，而非虚拟机认可的。**

例:(遍历数组)
```
String[] strArr = {"one","two","three","four","five"};

//新循环会被编译器在编译时改为普通的for循环遍历
for(String str : strArr) {
    System.out.println(str);
}
```

例:(遍历集合)
```
Collection c = new ArrayList();
c.add("one");
c.add("two");
c.add("three");

//编译器会将使用新循环遍历集合改为使用迭代器遍历，因此不要在遍历的过程中通过集合的方法增删元素。

for(Object o : c) {
    String str = (String)o;
    System.out.println(str);
}
```

## 泛型

>JDK5之后推出了另一个特性:泛型。泛型是用来在使用一个类时指定它的属性，方法参数和返回值的类型的，这个提高代码的灵活度。

**泛型最常使用的地方就是集合中，用来使用集合时规定集合中的元素类型。**




